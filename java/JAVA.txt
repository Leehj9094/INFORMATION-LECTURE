02.25

자료형
실수
float(32bit) : 실수 리터럴 뒤에 f 또는 F를 붙여야 사용 가능함
소수 5자리까지만 정확하게 표현 그 이상은 정확하게 표현하지 못함
double(64bit) : 자바의 실수 타입 기본 처리
소수 14자리 까지 오차없이 표현 가능

소수점
고정 소수점 
- 표현할 수 있는 범위가 매우 적음 / 다 쓰지 않아도 모두 사용하기에 낭비되는 공간도 많음
- 소수부의 자릿수를 미리 정하고 고정된 자릿수의 소수를 표현하기에 직관적임
정수부와 소수부로 고정으로 나누고 지정함

부동 소수점 (현재)
- 직관적이지 않아 고정된 값을 쓰지 않고 유연하게 사용됨 /큰 범위의 값을 표현하기에 유용함
배정도 (부호, 가수부, 지수부)
- 부호
- 가수부 : 실제 실수 데이터 값을 표현하는 부분 
(10진수로 float은 7자리 / double은 15자리)
- 지수부 : 소수점의 위치를 가리키는 제곱승이 들어감
자릿수 크기를 나타내는 부분

단일문자 
char(문자형 , 2byte) - 양수 값으로만 가능함 / ' ' 사용
- c를 정수로 변환하여 int타입으로 형 변환을 해줌
- 할당된 문자 리터럴이 저장될 때 아스키코드값으로 치환 되고 연산자를 이용하여 int로 변형 발생
- 나타낼 수 있는 방법 : ASCII코드, 유니코드, 문자 
(char c1 = 'a';	/ char c2 = 97;	/ char c3 = '\u0061';)-> 순서대로 나타낼 수 있음

String(문자열)
- 문자열 리터럴을 선언할 때 리터럴이 같으면 변수는 같은 참조값 으로 할당을 받아 반환되는 것 ==
- 문장으로써 문자 및 단어 등으로 구성된 문자들의 집합
- 클래스 자료형(String)
- 기본자료형(int, double, boolean) 

boolean(논리형)
- 주로 프로그램의 흐름을 제어하는 변수로 사용됨
true / false 논리값을 반환함

상수
- 변하지 말아야 할 데이터를 임시적으로 저장하기 위한 수단으로 사용됨
리터럴 상수
: 변수의 값이 변하지 않는 데이터 (메모리 위치 안의 값)
: 데이터 그 자체
: 변하지 않는 데이터 (short, long, int, char 등)을 리터럴이라 부름 - 문자열을 자바에서는 리터럴로 표현
심볼릭 상수
: "이름" 이 있는 상수
: 자료형 앞에 final 을 붙인다
(final int mun2 = 4; -> 자료형 앞에 붙이면 됨)

02.26

<단축키>----------------------------
자동 import : ctrl+shift+o 
 자동 formatting : ctrl+shift+f
--------------------------------------

형변환(TypeChange)
자동형변환(암시적 형변환)
: 변수 간 연산처리
- 낮은 자료형으로 맞출 때

byte > short,char > int > long > float > double
(long:8byte / float:4byte 이지만 일반적으로 메모리 설계상 정수 타입보다 실수 타입이 더 크게 되어 있기 때문에 long 보다 float이 더 크다-float은 부동소수점 방식표현으로 )

강제형변환(명시적 형변환)
- 높은 자료형으로 맞출 때
- 큰 데이터를 작은 데이터 타입으로 옮길 때 데이터 손실이 일어날 수 있음
- 실수 타입을 정수 타입으로 강제 변환하여 소수점 이하의 데이터들은 버려짐

정수연산식
- int 보다 long 으로 자동 형 변환
실수연산식
- 큰 타입으로 자동형변환

String
string -> int 로 변환시(문자 -> 숫자로 변환)
Integer.parselnt() : 문자열 파싱하여 int 객체 생성
double / short / long 도 가능 
(Double.parseDouble / Short.parseShort / Long.parseLong)
char는 integer가 없음

--------------------------------------------------------------------------------
Scanner
- 스트림(stream) : 단방향성 / 데이터의 이동 통로

- 표준입력 스트림(System.in) : 키보드 
 
- 표준출력 스트림(System.out) : 모니터

- 코드 해석 : 

nextLine : 띄어쓰기를 기준으로 입력 값을 읽고 나타냄
enter키를 입력하는 순간 문자를 처리하지 못하고 버퍼에 남겨 두게 됨

Buffer : 한번에 옮기는
- 컴퓨터에 입력받는 값이 많으면 많을 수록 사용하여 데이터를 입출력 하는게
Scanner를 통해 하나하나 출력하는것보다 훨씬 빠름
- enter키를 사용하면 경계로 인식하기 때문 중간에 띄어쓰기라도 하는 경우 데이터를 가공해주어야 함

--------------------------------------------------------------------------------
연산자

Thread.sleep


02.27

조건문 : 조건에 따라 코드의 실행 흐름을 다르게 동작하도록 제어하는 
- 주어진 조건을 판단하여 조건에 만족하면 지정된 명령 실행, 벗 만족하지 못할 경우는 명령을 실행하지 않음
if : 조건식의 결과가 true 또는 false 에 따라 실행여부가 결정됨
조건이 하나일 경우 if를 사용

if else : 조건이 두 개일 경우 사용

if else if : 조건문이 여러 개일 경우 사용 되는데 제한은 없고 여러 개 조건식 중 참(true)이 되는 블록만 실행하고 조건을 벗어나게 됨
else if문 마지막에는 else 를 추가할 수 잇지만 모든 조건식이 거짓(false)일 경우 else 를 실행하고 벗어나게 됨

switch
- 변수가 어떤 값을 갖느냐에 따라 실행문이 결정됨
- 가독성이 높은 좋은 코드를 작성할 수 있음
- 변수의 값에 따라 실행문이 결정되므로 같은 기능의 if문 보다 코드가 간결
- case로 가서 실행문을 실행 (case 가 없다면 default로 가서 실행 - default생략 가능함)
- case 블럭은 마지막에 break을 반드시 작성해야 함
(벗! default 일때는 break사용 안함)
<break?
+ 메소드, 반복문, switch, 명령문을 종료하는 역할
+ 하위에 있는 명령문을 실행하지 않고 코드 블록을 벗어나게 함
+ 만나는 즉시 for문을 종료하고 다음 실행문으로 넘어감
>
- 조건식을 넣을 수 없고 상수만 가능함 

-----------------------------------------------------
while 문
- 
- 반복문
- 조건이 참(true)이면 반복문에 계속 실행되지만 
  조건이 거짓(false)이면 반복문은 종료됨
- 조건문에서 빠져나가기 위해선 break를 사용
(System.out.println("커피가 다 떨어졌습니다. 판매를 중지합니다."); break;) - 끊고자 하는 마지막 조건 뒤에 break를 붙임
 
다시 돌아가고 싶으면 "continue"


03.05

객체지향

객체 - 클래스

클래스(선) -> 객(생성)

속성(멤버 변수)
기능(멤버 함수)
생성자

오버로딩 - 기존에 없는 새로운 메소드를 추가하는 것
(반환자료형, 함수명, 파라미터)


오버라이딩 - 상속받은 메소드를 재정의 하는 것
: 부모클래스로부터 상속받은 메소드를 자식 클래스에서 재정의
: 부모 클래스의 메소드를 재정의 하는 것으로 자식 클래서에서 오버라이딩하고자 하는 메소드의 이름, 변수, 리턴 값이 모두 같아야함

정보 은닉
- 접근 제어자 : private, default, protected, public
private > default > protected > public

- public : 모든 클래스(누구나) 접근 가능
- private : 해당 클래스(private이 붙은 변수, 메소드)에서만 접근 가능
- protected : 상속 관계를 가지는 경우에나 같은 패키지 내에 있을 때 접근 가능
- default : 접근 제어자를 별도로 설정하지 않으면 같은 패키지 내에 있을 때 접근 가능

- getter : 멤버 클래스 내에 있는 변수에 저장되어 있는 회원의 아이디값을 리턴
(public void setId(String Id) { this.Id = Id;})
- 외부에서 객체의 데이터를 읽을 때도 메소드를 사용

- setter : 멤버 클래스 내에 있는 변수에 회원의 아이디값을 저장
(public String getId() {return id;})
- 데이터는 외부에서 접근하지 않도록 막고,
메소드는 공개하여 외부에서 메소드를 통해 데이터에 접근하도록 유도

vo = view only

캡슐화(Encapsulation)?
- 서로 연관있는 속성과 기능들을 하나의 캡슐로 만들어 데이터를 외부로부터 보호함 
- 데이터와 알고리즘을 하나로 묶는 것
- 관련이 있는 변수와 함수를 하나의 클래스로 묶고 외부에서 쉽게 접근하지 
  못하도록 은닉 -> 데이터 은닉(data hiding)
- 객체에 직접적인 접근을 막고 내부의 정보에 직접접근 하거나 변경 X 
-> 데이터 보호(data protection)
  객체가 제공하는 필드와 메소드를 통해서만 접근 O
public > default > protected > private

this란?
- 객체 자신을 가리키는 래퍼런스 변수
- 자신의 객체에 접근할 때 사용(멤버 변수와 매개변수의 이름이 동일 시 구분)
- 인스턴스 자신의 주소를 반환할 때 사용
 

String Class (시험에 나올거임!!!)
- 한 번 생성되면 그 값을 읽기만 할 수 있고 변경하기 어려움
- 불변객체(immutable object)
- 문자열 대입 (바로 대입시키지 않고 new 연산자를 통해 객체 생성)

API ?

concat?
- String 클래스에서 제공하는 기본 메서드
- 주어진 문자열의 끝에 지정된 문자열을 추가한 다음 반환하고 형성된 
새 문자열을 반환
- 세개 이상의 문자열을 결합할 수 있음
- 문자열을 변경하지 않고 현재 문자열과 매개 변수로 전달된 문자열을 병함 및 새 문자열을 생성함
- 문자열을 한 번만 병합해야 할 때 사용

---------------------------------------------------------------------------
배열(Array)
- 동일한 타입의 여러 값을 저장할 수 있는 자료구조
- 배열 사용시 많은 양의 데이터를 적은 코드로 쉽게 처리할 수 있음
- 배열은 하나의 블록 안에 같은 타입인 데이터 여러 개를 모아 저장
- 각각의 값을 배열요소, 위치를 인덱스라 부름
- 배열은 공간의 개수(길이) 설정이 필수임
- 출력은 for문이나 Arrays.toString 사용


03.06

static
- 클래스 레벨에서 선언되며 모든 인스턴스에 의해 공유됨
- 특정 데이터를 모든 인스턴스가 공유해야 할 때 유용
- 동일한 값을 유지해야 할 때 효과적
- 메모리 사용 최적화 할 수 있음
- 벗 변수가 필요한 경우에만 제한적으로 사용해야 함 왜냐 남용은 객체지향의 원칙에 어긋나고 메모리 관리 측에도 부정적인 영향을 끼침
- 인스턴스 생성 없이 클래스 이름을 통해 직접 호출 가능
- 연산에 주로 사용됨
- But 클래스의 다른 static 메소드나 변수만 접근 가능하며, 인스턴스로 접근해야 하는 경우 사용할 수 없음 (사용 시에는 이런 제한을 고려해야 함)
- 클래스가 처음 로드될 때 한 번만 실행되는 코드 
- 초기화 작업에 적합

-------------------------------------------------------------------------------
singleton Pattern(DBCP-DataBase Connection Pool)  - 셤에 나옴 (외워 이현정!)
- 하나의 인스턴스만 가지는 패턴
-  단하나의 유일한 객체를 만들기 위한 코드 패턴!
-> 메모리를 절약 하며 새로 만들지 않고 기존의 인스턴스를 가져와 활용함
- 모듈간의 의존성이 높아짐..

--------------------------------------------------------------------------------
절차
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
저장
--------------------------------------------------------------------------------
자료형 (정수, 실수, 단일문자, 문자열)
data(수) - 상수 ,  변수
-------------------------------------------------------------------------------
처리
-------------------------------------------------------------------------
연산자(기본, 대입, 복합대입, 논리, 삼항, 증감 등)
형변환
흐름제어문(if, switch, for, while 등)
-------------------------------------------------------------------------
객체
-------------------------------------------------------------------------------
일반 
- 객체 ? , Instance , 클래스 , JVM 메모리구조
객체구성요소
- 객체속성(멤버 변수 / 필드)
- 객체기능(멤버함수 / 생성자함수 / 함수오버로딩)
- static(관련 디자인패턴 : 싱글톤패턴)

자료구조
- 배열(원시타입 / 클래스타입)
- collection(List, Set, Map 등)
-------------------------------------------------------------------------------
상속(inheritance)
-------------------------------------------------------------------------------
- 상위클래스와 자식클래스가 있으며,
자식클래스는 부모클래스의 상속을 받아 그대로 사용 가능 함
- 이미 있는 것들 재사용 해서 만들수 있음
- 상속 받고자 하는 자식 클래스 명 옆에 extends 키워드를 붙이고 상속할
부모 클래스를 적음
- But 다중 상속을 허용하지 않아서 extends 뒤엔 하나의 부모 클래스만 올수 있음
- super : 부모생성자를 호출
(자식클래스에서 생성자 내부 첫줄에 super();를 선언해주어야 함)

